!function(){try{var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},t=(new e.Error).stack;t&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[t]="f1945da7-7932-4a6e-b607-dea450b32cb4",e._sentryDebugIdIdentifier="sentry-dbid-f1945da7-7932-4a6e-b607-dea450b32cb4")}catch(e){}}();"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7547],{50821:(e,t,n)=>{n.d(t,{L4:()=>aS,bi:()=>a_,eU:()=>am,lZ:()=>av,vc:()=>ag});var r,o,a,i=n(53239),l=n(37034),s=function(e){let t=Error(e);if(void 0===t.stack)try{throw t}catch(e){}return t},u=function(e){return!!e&&"function"==typeof e.then},c=function(e,t){if(null!=e)return e;throw s(null!=t?t:"Got unexpected null or undefined")};function f(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class d{getValue(){throw s("BaseLoadable")}toPromise(){throw s("BaseLoadable")}valueMaybe(){throw s("BaseLoadable")}valueOrThrow(){throw s(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw s("BaseLoadable")}promiseOrThrow(){throw s(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw s("BaseLoadable")}errorOrThrow(){throw s(`Loadable expected error, but in "${this.state}" state`)}is(e){return e.state===this.state&&e.contents===this.contents}map(e){throw s("BaseLoadable")}}class h extends d{constructor(e){super(),f(this,"state","hasValue"),f(this,"contents",void 0),this.contents=e}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(e){try{let t=e(this.contents);return u(t)?g(t):v(t)?t:_(t)}catch(t){return u(t)?g(t.next(()=>this.map(e))):m(t)}}}class p extends d{constructor(e){super(),f(this,"state","hasError"),f(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(e){return this}}class y extends d{constructor(e){super(),f(this,"state","loading"),f(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(e){return g(this.contents.then(t=>{let n=e(t);if(v(n))switch(n.state){case"hasValue":case"loading":return n.contents;case"hasError":throw n.contents}return n}).catch(t=>{if(u(t))return t.then(()=>this.map(e).contents);throw t}))}}function _(e){return Object.freeze(new h(e))}function m(e){return Object.freeze(new p(e))}function g(e){return Object.freeze(new y(e))}function S(e){var t;let n=(t=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])).map(e=>v(e)?e:u(e)?g(e):_(e))).every(e=>"hasValue"===e.state)?_(t.map(e=>e.contents)):t.some(e=>"hasError"===e.state)?m(c(t.find(e=>"hasError"===e.state),"Invalid loadable passed to loadableAll").contents):g(Promise.all(t.map(e=>e.contents)));return Array.isArray(e)?n:n.map(t=>Object.getOwnPropertyNames(e).reduce((e,n,r)=>({...e,[n]:t[r]}),{}))}function v(e){return e instanceof d}var b={loadableWithValue:_,loadableWithError:m,loadableWithPromise:g,loadableLoading:function(){return Object.freeze(new y(new Promise(()=>{})))},loadableAll:S,isLoadable:v,RecoilLoadable:{of:e=>u(e)?g(e):v(e)?e:_(e),error:e=>m(e),all:S,isLoadable:v}},T=Object.freeze({__proto__:null,loadableWithValue:b.loadableWithValue,loadableWithError:b.loadableWithError,loadableWithPromise:b.loadableWithPromise,loadableLoading:b.loadableLoading,loadableAll:b.loadableAll,isLoadable:b.isLoadable,RecoilLoadable:b.RecoilLoadable});class R{constructor(e){f(this,"key",void 0),this.key=e}}class w extends R{}class A extends R{}var E={AbstractRecoilValue:R,RecoilState:w,RecoilValueReadOnly:A,isRecoilValue:function(e){return e instanceof w||e instanceof A}},N=Object.freeze({__proto__:null,AbstractRecoilValue:E.AbstractRecoilValue,RecoilState:E.RecoilState,RecoilValueReadOnly:E.RecoilValueReadOnly,isRecoilValue:E.isRecoilValue}),k=function(e){};let V=new Map().set("recoil_hamt_2020",!0).set("recoil_sync_external_store",!0).set("recoil_suppress_rerender_in_callback",!0).set("recoil_memory_managament_2020",!0);function L(e){var t;return null!=(t=V.get(e))&&t}L.setPass=e=>{V.set(e,!0)},L.setFail=e=>{V.set(e,!1)},L.clear=()=>{V.clear()};var M=function(e,t){return function*(){let n=0;for(let r of e)yield t(r,n++)}()},C=function(e,t,{error:n}={}){return null};class U{}let B=new U;class D extends Error{constructor(e){super(`Tried to set the value of Recoil selector ${e} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}let I=new Map,O=new Map;class x extends Error{}let P=new Map;function z(e){return P.get(e)}var F={nodes:I,recoilValues:O,registerNode:function(e){I.has(e.key)&&console.warn(`Duplicate atom key "${e.key}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`),I.set(e.key,e);let t=null==e.set?new N.RecoilValueReadOnly(e.key):new N.RecoilState(e.key);return O.set(e.key,t),t},getNode:function(e){let t=I.get(e);if(null==t)throw new x(`Missing definition for RecoilValue: "${e}""`);return t},getNodeMaybe:function(e){return I.get(e)},deleteNodeConfigIfPossible:function(e){var t,n;if(!L("recoil_memory_managament_2020"))return;let r=I.get(e);null!=r&&null!=(t=r.shouldDeleteConfigOnRelease)&&t.call(r)&&(I.delete(e),null==(n=z(e))||n(),P.delete(e))},setConfigDeletionHandler:function(e,t){L("recoil_memory_managament_2020")&&(void 0===t?P.delete(e):P.set(e,t))},getConfigDeletionHandler:z,recoilValuesForKeys:function(e){return M(e,e=>c(O.get(e)))},NodeMissingError:x,DefaultValue:U,DEFAULT_VALUE:B,RecoilValueNotReady:D},$={enqueueExecution:function(e,t){t()}},W=function(e,t){return e(t={exports:{}},t.exports),t.exports}(function(e){var t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n={},r={},o=function(e){return function(){return e}},a=n.hash=function(e){var n=void 0===e?"undefined":t(e);if("number"===n)return e;"string"!==n&&(e+="");for(var r=0,o=0,a=e.length;o<a;++o)r=(r<<5)-r+e.charCodeAt(o)|0;return r},i=function(e,t){return t>>>e&31},l=function(e){return 1<<e},s=function(e,t){var n;return n=e&t-1,n-=n>>1&0x55555555,n=(n=(0x33333333&n)+(n>>2&0x33333333))+(n>>4)&0xf0f0f0f,n+=n>>8,127&(n+=n>>16)},u=function(e,t,n,r){var o=r;if(!e){var a=r.length;o=Array(a);for(var i=0;i<a;++i)o[i]=r[i]}return o[t]=n,o},c=function(e,t,n){var r=n.length-1,o=0,a=0,i=n;if(e)o=a=t;else for(i=Array(r);o<t;)i[a++]=n[o++];for(++o;o<=r;)i[a++]=n[o++];return e&&(i.length=r),i},f=function(e,t,n,r){var o=r.length;if(e){for(var a=o;a>=t;)r[a--]=r[a];return r[t]=n,r}for(var i=0,l=0,s=Array(o+1);i<t;)s[l++]=r[i++];for(s[t]=n;i<o;)s[++l]=r[i++];return s},d={__hamt_isEmpty:!0},h=function(e){return e===d||e&&e.__hamt_isEmpty},p=function(e,t,n,r){return{type:1,edit:e,hash:t,key:n,value:r,_modify:R}},y=function(e,t,n){return{type:2,edit:e,hash:t,children:n,_modify:w}},_=function(e,t,n){return{type:3,edit:e,mask:t,children:n,_modify:A}},m=function(e,t,n){return{type:4,edit:e,size:t,children:n,_modify:E}},g=function(e,t,n,r,o){for(var a=[],i=r,l=0,s=0;i;++s)1&i&&(a[s]=o[l++]),i>>>=1;return a[t]=n,m(e,l+1,a)},S=function(e,t,n,r){for(var o=Array(t-1),a=0,i=0,l=0,s=r.length;l<s;++l)if(l!==n){var u=r[l];u&&!h(u)&&(o[a++]=u,i|=1<<l)}return _(e,i,o)},v=function e(t,n,r,o,a,s){if(r===a)return y(t,r,[s,o]);var u=i(n,r),c=i(n,a);return _(t,l(u)|l(c),u===c?[e(t,n+5,r,o,a,s)]:u<c?[o,s]:[s,o])},b=function(e,t,n,o,a,i,l,s){for(var f=a.length,d=0;d<f;++d){var h=a[d];if(n(l,h.key)){var y=h.value,_=i(y);if(_===y)return a;if(_===r)return--s.value,c(e,d,a);return u(e,d,p(t,o,l,_),a)}}var m=i();return m===r?a:(++s.value,u(e,f,p(t,o,l,m),a))},T=function(e,t){return e===t.edit},R=function(e,t,n,o,a,i,l){if(t(i,this.key)){var s=o(this.value);return s===this.value?this:s===r?(--l.value,d):T(e,this)?(this.value=s,this):p(e,a,i,s)}var u=o();return u===r?this:(++l.value,v(e,n,this.hash,this,a,p(e,a,i,u)))},w=function(e,t,n,o,a,i,l){if(a===this.hash){var s=b(T(e,this),e,t,this.hash,this.children,o,i,l);return s===this.children?this:s.length>1?y(e,this.hash,s):s[0]}var u=o();return u===r?this:(++l.value,v(e,n,this.hash,this,a,p(e,a,i,u)))},A=function(e,t,n,r,o,a,p){var y,m=this.mask,S=this.children,v=i(n,o),b=l(v),R=s(m,b),w=m&b,A=w?S[R]:d,E=A._modify(e,t,n+5,r,o,a,p);if(A===E)return this;var N=T(e,this),k=m,V=void 0;if(w&&h(E)){if(!(k&=~b))return d;if(S.length<=2&&((y=S[1^R])===d||1===y.type||2===y.type))return S[1^R];V=c(N,R,S)}else if(w||h(E))V=u(N,R,E,S);else{if(S.length>=16)return g(e,v,E,m,S);k|=b,V=f(N,R,E,S)}return N?(this.mask=k,this.children=V,this):_(e,k,V)},E=function(e,t,n,r,o,a,l){var s=this.size,c=this.children,f=i(n,o),p=c[f],y=(p||d)._modify(e,t,n+5,r,o,a,l);if(p===y)return this;var _=T(e,this),g=void 0;if(h(p)&&!h(y))++s,g=u(_,f,y,c);else if(!h(p)&&h(y)){if(--s<=8)return S(e,s,f,c);g=u(_,f,d,c)}else g=u(_,f,y,c);return _?(this.size=s,this.children=g,this):m(e,s,g)};function N(e,t,n,r,o){this._editable=e,this._edit=t,this._config=n,this._root=r,this._size=o}d._modify=function(e,t,n,o,a,i,l){var s=o();return s===r?d:(++l.value,p(e,a,i,s))},N.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new N(this._editable,this._edit,this._config,e,t)};var k=n.tryGetHash=function(e,t,n,r){for(var o=r._root,a=0,u=r._config.keyEq;;)switch(o.type){case 1:return u(n,o.key)?o.value:e;case 2:if(t===o.hash)for(var c=o.children,f=0,d=c.length;f<d;++f){var h=c[f];if(u(n,h.key))return h.value}return e;case 3:var p=l(i(a,t));if(o.mask&p){o=o.children[s(o.mask,p)],a+=5;break}return e;case 4:if(o=o.children[i(a,t)]){a+=5;break}return e;default:return e}};N.prototype.tryGetHash=function(e,t,n){return k(e,t,n,this)};var V=n.tryGet=function(e,t,n){return k(e,n._config.hash(t),t,n)};N.prototype.tryGet=function(e,t){return V(e,t,this)};var L=n.getHash=function(e,t,n){return k(void 0,e,t,n)};N.prototype.getHash=function(e,t){return L(e,t,this)},n.get=function(e,t){return k(void 0,t._config.hash(e),e,t)},N.prototype.get=function(e,t){return V(t,e,this)};var M=n.has=function(e,t,n){return k(r,e,t,n)!==r};N.prototype.hasHash=function(e,t){return M(e,t,this)};var C=n.has=function(e,t){return M(t._config.hash(e),e,t)};N.prototype.has=function(e){return C(e,this)};var U=function(e,t){return e===t};n.make=function(e){return new N(0,0,{keyEq:e&&e.keyEq||U,hash:e&&e.hash||a},d,0)},n.empty=n.make();var B=n.isEmpty=function(e){return e&&!!h(e._root)};N.prototype.isEmpty=function(){return B(this)};var D=n.modifyHash=function(e,t,n,r){var o={value:r._size},a=r._root._modify(r._editable?r._edit:NaN,r._config.keyEq,0,e,t,n,o);return r.setTree(a,o.value)};N.prototype.modifyHash=function(e,t,n){return D(n,e,t,this)};var I=n.modify=function(e,t,n){return D(e,n._config.hash(t),t,n)};N.prototype.modify=function(e,t){return I(t,e,this)};var O=n.setHash=function(e,t,n,r){return D(o(n),e,t,r)};N.prototype.setHash=function(e,t,n){return O(e,t,n,this)};var x=n.set=function(e,t,n){return O(n._config.hash(e),e,t,n)};N.prototype.set=function(e,t){return x(e,t,this)};var P=o(r),z=n.removeHash=function(e,t,n){return D(P,e,t,n)};N.prototype.removeHash=N.prototype.deleteHash=function(e,t){return z(e,t,this)};var F=n.remove=function(e,t){return z(t._config.hash(e),e,t)};N.prototype.remove=N.prototype.delete=function(e){return F(e,this)};var $=n.beginMutation=function(e){return new N(e._editable+1,e._edit+1,e._config,e._root,e._size)};N.prototype.beginMutation=function(){return $(this)};var W=n.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};N.prototype.endMutation=function(){return W(this)};var G=n.mutate=function(e,t){var n=$(t);return e(n),W(n)};N.prototype.mutate=function(e){return G(e,this)};var j=function(e){return e&&H(e[0],e[1],e[2],e[3],e[4])},H=function(e,t,n,r,o){for(;n<e;){var a=t[n++];if(a&&!h(a))return q(a,r,[e,t,n,r,o])}return j(o)},q=function(e,t,n){switch(e.type){case 1:return{value:t(e),rest:n};case 2:case 4:case 3:var r=e.children;return H(r.length,r,0,t,n);default:return j(n)}},K={done:!0};function Z(e){this.v=e}Z.prototype.next=function(){if(!this.v)return K;var e=this.v;return this.v=j(e.rest),e},Z.prototype[Symbol.iterator]=function(){return this};var Y=function(e,t){return new Z(q(e._root,t))},J=function(e){return[e.key,e.value]},X=n.entries=function(e){return Y(e,J)};N.prototype.entries=N.prototype[Symbol.iterator]=function(){return X(this)};var Q=function(e){return e.key},ee=n.keys=function(e){return Y(e,Q)};N.prototype.keys=function(){return ee(this)};var et=function(e){return e.value},en=n.values=N.prototype.values=function(e){return Y(e,et)};N.prototype.values=function(){return en(this)};var er=n.fold=function(e,t,n){var r=n._root;if(1===r.type)return e(t,r.value,r.key);for(var o=[r.children],a=void 0;a=o.pop();)for(var i=0,l=a.length;i<l;){var s=a[i++];s&&s.type&&(1===s.type?t=e(t,s.value,s.key):o.push(s.children))}return t};N.prototype.fold=function(e,t){return er(e,t,this)};var eo=n.forEach=function(e,t){return er(function(n,r,o){return e(r,o,t)},null,t)};N.prototype.forEach=function(e){return eo(e,this)};var ea=n.count=function(e){return e._size};N.prototype.count=function(){return ea(this)},Object.defineProperty(N.prototype,"size",{get:N.prototype.count}),e.exports?e.exports=n:undefined.hamt=n});class G{constructor(e){f(this,"_map",void 0),this._map=new Map(null==e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return H(this)}toMap(){return new Map(this._map)}}class j{constructor(e){if(f(this,"_hamt",W.empty.beginMutation()),e instanceof j){let t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(let[t,n]of e.entries())this._hamt.set(t,n)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return H(this)}toMap(){return new Map(this._hamt)}}function H(e){return L("recoil_hamt_2020")?new j(e):new G(e)}var q=Object.freeze({__proto__:null,persistentMap:{persistentMap:H}.persistentMap}),K=function(e,...t){let n=new Set;e:for(let r of e){for(let e of t)if(e.has(r))continue e;n.add(r)}return n},Z=function(e,t){let n=new Map;return e.forEach((e,r)=>{n.set(r,t(e,r))}),n};function Y(e,t,n){let{nodeDeps:r,nodeToNodeSubscriptions:o}=t;e.forEach((e,t)=>{let a=r.get(t);a&&n&&a!==n.nodeDeps.get(t)||(r.set(t,new Set(e)),(null==a?e:K(e,a)).forEach(e=>{o.has(e)||o.set(e,new Set),c(o.get(e)).add(t)}),a&&K(a,e).forEach(e=>{if(!o.has(e))return;let n=c(o.get(e));n.delete(t),0===n.size&&o.delete(e)}))})}var J={addToDependencyMap:function(e,t,n){n.has(e)||n.set(e,new Set),c(n.get(e)).add(t)},cloneGraph:function(e){return{nodeDeps:Z(e.nodeDeps,e=>new Set(e)),nodeToNodeSubscriptions:Z(e.nodeToNodeSubscriptions,e=>new Set(e))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(e,t){e.forEach((e,n)=>{t.has(n)||t.set(n,new Set);let r=c(t.get(n));e.forEach(e=>r.add(e))})},saveDependencyMapToStore:function(e,t,n){var r,o,a,i,l;let s=t.getState();n!==s.currentTree.version&&n!==(null==(r=s.nextTree)?void 0:r.version)&&n!==(null==(o=s.previousTree)?void 0:o.version)&&C("Tried to save dependencies to a discarded tree");let u=t.getGraph(n);if(Y(e,u),n===(null==(a=s.previousTree)?void 0:a.version)&&Y(e,t.getGraph(s.currentTree.version),u),n===(null==(i=s.previousTree)?void 0:i.version)||n===s.currentTree.version){let n=null==(l=s.nextTree)?void 0:l.version;void 0!==n&&Y(e,t.getGraph(n),u)}}};let X=0,Q=0,ee=0;var et={getNextTreeStateVersion:()=>X++,getNextStoreID:()=>Q++,getNextComponentID:()=>ee++};let{persistentMap:en}=q,{graph:er}=J,{getNextTreeStateVersion:eo}=et;function ea(){let e=eo();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:en(),nonvalidatedAtoms:en()}}var ei={makeEmptyTreeState:ea,makeEmptyStoreState:function(){let e=ea();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,er()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:eo};class el{}var es={RetentionZone:el,retentionZone:function(){return new el}},eu={setByAddingToSet:function(e,t){let n=new Set(e);return n.add(t),n},setByDeletingFromSet:function(e,t){let n=new Set(e);return n.delete(t),n},mapBySettingInMap:function(e,t,n){let r=new Map(e);return r.set(t,n),r},mapByUpdatingInMap:function(e,t,n){let r=new Map(e);return r.set(t,n(r.get(t))),r},mapByDeletingFromMap:function(e,t){let n=new Map(e);return n.delete(t),n},mapByDeletingMultipleFromMap:function(e,t){let n=new Map(e);return t.forEach(e=>n.delete(e)),n}},ec=function*(e,t){let n=0;for(let r of e)t(r,n++)&&(yield r)},ef=function(e,t){return new Proxy(e,{get:(e,n)=>(!(n in e)&&n in t&&(e[n]=t[n]()),e[n]),ownKeys:e=>Object.keys(e)})};let{getNode:ed,getNodeMaybe:eh,recoilValuesForKeys:ep}=F,{RetentionZone:ey}=es,{setByAddingToSet:e_}=eu,em=Object.freeze(new Set);class eg extends Error{}function eS(e,t,n,r){let o=e.getState();if(o.nodeCleanupFunctions.has(n))return;let a=ed(n),i=function(e,t,n){if(!L("recoil_memory_managament_2020"))return()=>void 0;let{nodesRetainedByZone:r}=e.getState().retention;function o(e){let n=r.get(e);n||r.set(e,n=new Set),n.add(t)}if(n instanceof ey)o(n);else if(Array.isArray(n))for(let e of n)o(e);return()=>{if(!L("recoil_memory_managament_2020"))return;let{retention:r}=e.getState();function o(e){let n=r.nodesRetainedByZone.get(e);null==n||n.delete(t),n&&0===n.size&&r.nodesRetainedByZone.delete(e)}if(n instanceof ey)o(n);else if(Array.isArray(n))for(let e of n)o(e)}}(e,n,a.retainedBy),l=a.init(e,t,r);o.nodeCleanupFunctions.set(n,()=>{l(),i()})}function ev(e,t,n){return ed(n).peek(e,t)}function eb(e,t,n){let r=new Set,o=Array.from(n),a=e.getGraph(t.version);for(let e=o.pop();e;e=o.pop()){var i;for(let t of(r.add(e),null!=(i=a.nodeToNodeSubscriptions.get(e))?i:em))r.has(t)||o.push(t)}return r}var eT={getNodeLoadable:function(e,t,n){return eS(e,t,n,"get"),ed(n).get(e,t)},peekNodeLoadable:ev,setNodeValue:function(e,t,n,r){let o=ed(n);if(null==o.set)throw new eg(`Attempt to set read-only RecoilValue: ${n}`);let a=o.set;return eS(e,t,n,"set"),a(e,t,r)},initializeNode:function(e,t,n){eS(e,e.getState().currentTree,t,n)},cleanUpNode:function(e,t){var n;let r=e.getState();null==(n=r.nodeCleanupFunctions.get(t))||n(),r.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,n){var r;let o=eh(t);return null==o||null==(r=o.invalidate)||r.call(o,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:e_(e.dirtyAtoms,t)}},peekNodeInfo:function(e,t,n){let r=e.getState(),o=e.getGraph(t.version),a=ed(n).nodeType;return ef({type:a},{loadable:()=>ev(e,t,n),isActive:()=>r.knownAtoms.has(n)||r.knownSelectors.has(n),isSet:()=>"selector"!==a&&t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var e;return ep(null!=(e=o.nodeDeps.get(n))?e:[])},subscribers:()=>{var o,a;return{nodes:ep(ec(eb(e,t,new Set([n])),e=>e!==n)),components:M(null!=(o=null==(a=r.nodeToComponentSubscriptions.get(n))?void 0:a.values())?o:[],([e])=>({name:e}))}}})},getDownstreamNodes:eb};let eR=null!=(r=i.createMutableSource)?r:i.unstable_createMutableSource,ew=null!=(o=i.useMutableSource)?o:i.unstable_useMutableSource,eA=null!=(a=i.useSyncExternalStore)?a:i.unstable_useSyncExternalStore;var eE={createMutableSource:eR,useMutableSource:ew,useSyncExternalStore:eA,reactMode:function(){return L("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:L("recoil_sync_external_store")&&null!=eA?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:L("recoil_mutable_source")&&null!=ew&&"undefined"!=typeof window&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?L("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:L("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}};let{getDownstreamNodes:eN,getNodeLoadable:ek,setNodeValue:eV}=eT,{getNextComponentID:eL}=et,{getNode:eM,getNodeMaybe:eC}=F,{DefaultValue:eU,RecoilValueNotReady:eB}=F,{reactMode:eD}=eE,{AbstractRecoilValue:eI,RecoilState:eO,RecoilValueReadOnly:ex,isRecoilValue:eP}=N;function ez(e,t,n){"hasValue"===n.state&&n.contents instanceof eU?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function eF(e,t){e.replaceState(n=>{let r=eG(n);for(let n of t)!function(e,t,n){if("set"===n.type){let{recoilValue:r,valueOrUpdater:o}=n,a=function(e,t,{key:n},r){if("function"!=typeof r)return r;{let o=ek(e,t,n);if("loading"===o.state)throw new eB(n);if("hasError"===o.state)throw o.contents;return r(o.contents)}}(e,t,r,o);for(let[n,o]of eV(e,t,r.key,a).entries())ez(t,n,o)}else if("setLoadable"===n.type){let{recoilValue:{key:e},loadable:r}=n;ez(t,e,r)}else if("markModified"===n.type){let{recoilValue:{key:e}}=n;t.dirtyAtoms.add(e)}else if("setUnvalidated"===n.type){var r;let{recoilValue:{key:e},unvalidatedValue:o}=n,a=eC(e);null==a||null==(r=a.invalidate)||r.call(a,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,o),t.dirtyAtoms.add(e)}else C(`Unknown action ${n.type}`)}(e,r,n);return ej(e,r),r})}function e$(e,t){if(eW.length){let n=eW[eW.length-1],r=n.get(e);r||n.set(e,r=[]),r.push(t)}else eF(e,[t])}let eW=[];function eG(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function ej(e,t){for(let o of eN(e,t,t.dirtyAtoms)){var n,r;null==(n=eC(o))||null==(r=n.invalidate)||r.call(n,t)}}function eH(e,t,n){e$(e,{type:"set",recoilValue:t,valueOrUpdater:n})}var eq={RecoilValueReadOnly:ex,AbstractRecoilValue:eI,RecoilState:eO,getRecoilValueAsLoadable:function(e,{key:t},n=e.getState().currentTree){var r,o;let a=e.getState();n.version!==a.currentTree.version&&n.version!==(null==(r=a.nextTree)?void 0:r.version)&&n.version!==(null==(o=a.previousTree)?void 0:o.version)&&C("Tried to read from a discarded tree");let i=ek(e,n,t);return"loading"===i.state&&i.contents.catch(()=>{}),i},setRecoilValue:eH,setRecoilValueLoadable:function(e,t,n){if(n instanceof eU)return eH(e,t,n);e$(e,{type:"setLoadable",recoilValue:t,loadable:n})},markRecoilValueModified:function(e,t){e$(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,n){e$(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})},subscribeToRecoilValue:function(e,{key:t},n,r=null){let o=eL(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),c(a.nodeToComponentSubscriptions.get(t)).set(o,[null!=r?r:"<not captured>",n]);let i=eD();if(i.early&&("LEGACY"===i.mode||"MUTABLE_SOURCE"===i.mode)){let r=e.getState().nextTree;r&&r.dirtyAtoms.has(t)&&n(r)}return{release:()=>{let n=e.getState(),r=n.nodeToComponentSubscriptions.get(t);if(void 0===r||!r.has(o))return void C(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`);r.delete(o),0===r.size&&n.nodeToComponentSubscriptions.delete(t)}}},isRecoilValue:eP,applyAtomValueWrites:function(e,t){let n=e.clone();return t.forEach((e,t)=>{"hasValue"===e.state&&e.contents instanceof eU?n.delete(t):n.set(t,e)}),n},batchStart:function(){let e=new Map;return eW.push(e),()=>{for(let[t,n]of e)eF(t,n);eW.pop()!==e&&C("Incorrect order of batch popping")}},writeLoadableToTreeState:ez,invalidateDownstreams:ej,copyTreeState:eG,refreshRecoilValue:function(e,t){var n;let{currentTree:r}=e.getState(),o=eM(t.key);null==(n=o.clearCache)||n.call(o,e,r)},invalidateDownstreams_FOR_TESTING:ej},eK=function(e,t,n){let r=e.entries(),o=r.next();for(;!o.done;){let a=o.value;if(t.call(n,a[1],a[0],e))return!0;o=r.next()}return!1};let{cleanUpNode:eZ}=eT,{deleteNodeConfigIfPossible:eY,getNode:eJ}=F,{RetentionZone:eX}=es,eQ=new Set;function e0(e,t){let n=e.getState(),r=n.currentTree;if(n.nextTree)return void C("releaseNodesNowOnCurrentTree should only be called at the end of a batch");let o=new Set;for(let e of t)if(e instanceof eX)for(let t of function(e,t){var n;return null!=(n=e.retention.nodesRetainedByZone.get(t))?n:eQ}(n,e))o.add(t);else o.add(e);for(let t of function(e,t){let n=e.getState(),r=n.currentTree,o=e.getGraph(r.version),a=new Set,i=new Set;return function t(l){var s,u;let f=new Set;for(let t of function(e,t,n,r,o){let a=e.getGraph(t.version),i=[],l=new Set;for(;n.size>0;)!function e(t){if(r.has(t)||o.has(t))return void n.delete(t);if(l.has(t))return;let s=a.nodeToNodeSubscriptions.get(t);if(s)for(let t of s)e(t);l.add(t),n.delete(t),i.push(t)}(c(n.values().next().value));return i}(e,r,l,a,i)){if("recoilRoot"===eJ(t).retainedBy||(null!=(s=n.retention.referenceCounts.get(t))?s:0)>0||e1(t).some(e=>n.retention.referenceCounts.get(e))){i.add(t);continue}let e=o.nodeToNodeSubscriptions.get(t);if(e&&eK(e,e=>i.has(e))){i.add(t);continue}a.add(t),f.add(t)}let d=new Set;for(let e of f)for(let t of null!=(u=o.nodeDeps.get(e))?u:eQ)a.has(t)||d.add(t);d.size&&t(d)}(t),a}(e,o))!function(e,t,n){var r,o;if(!L("recoil_memory_managament_2020"))return;eZ(e,n);let a=e.getState();for(let e of(a.knownAtoms.delete(n),a.knownSelectors.delete(n),a.nodeTransactionSubscriptions.delete(n),a.retention.referenceCounts.delete(n),e1(n)))null==(r=a.retention.nodesRetainedByZone.get(e))||r.delete(n);t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);let i=a.graphsByVersion.get(t.version);if(i){let e=i.nodeDeps.get(n);if(void 0!==e)for(let t of(i.nodeDeps.delete(n),e))null==(o=i.nodeToNodeSubscriptions.get(t))||o.delete(n);i.nodeToNodeSubscriptions.delete(n)}eY(n)}(e,r,t)}function e1(e){let t=eJ(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof eX?[t]:t}function e2(e,t){if(!L("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t);let n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):e0(e,new Set([t]))}var e3={SUSPENSE_TIMEOUT_MS:12e4,updateRetainCount:function(e,t,n){var r;if(!L("recoil_memory_managament_2020"))return;let o=e.getState().retention.referenceCounts,a=(null!=(r=o.get(t))?r:0)+n;0===a?e2(e,t):o.set(t,a)},updateRetainCountToZero:e2,releaseScheduledRetainablesNow:function(e){if(!L("recoil_memory_managament_2020"))return;let t=e.getState();e0(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};let{unstable_batchedUpdates:e5}=l,{unstable_batchedUpdates:e4}={unstable_batchedUpdates:e5},{batchStart:e7}=eq,{unstable_batchedUpdates:e6}={unstable_batchedUpdates:e4},e9=e6;var e8={getBatcher:()=>e9,setBatcher:e=>{e9=e},batchUpdates:e=>{e9(()=>{let t=()=>void 0;try{t=e7(),e()}finally{t()}})}},te=function*(e){for(let t of e)for(let e of t)yield e},tt={isSSR:"undefined"==typeof window,isReactNative:"undefined"!=typeof navigator&&"ReactNative"===navigator.product};let{batchUpdates:tn}=e8,{initializeNode:tr,peekNodeInfo:to}=eT,{graph:ta}=J,{getNextStoreID:ti}=et,{DEFAULT_VALUE:tl,recoilValues:ts,recoilValuesForKeys:tu}=F,{AbstractRecoilValue:tc,getRecoilValueAsLoadable:tf,setRecoilValue:td,setUnvalidatedRecoilValue:th}=eq,{updateRetainCount:tp}=e3,{getNextTreeStateVersion:ty,makeEmptyStoreState:t_}=ei,{isSSR:tm}=tt,{memoizeOneWithArgsHashAndInvalidation:tg}={memoizeWithArgsHash:function(e,t){let n;return(...r)=>{n||(n={});let o=t(...r);return Object.hasOwnProperty.call(n,o)||(n[o]=e.apply(this,r)),n[o]}},memoizeOneWithArgsHash:function(e,t){let n,r;return(...o)=>{let a=t(...o);return n===a?r:(n=a,r=e.apply(this,o))}},memoizeOneWithArgsHashAndInvalidation:function(e,t){let n,r;return[(...o)=>{let a=t(...o);return n===a?r:(n=a,r=e.apply(this,o))},()=>{n=null}]}};class tS{constructor(e){for(let t of(f(this,"_store",void 0),f(this,"_refCount",1),f(this,"getLoadable",e=>(this.checkRefCount_INTERNAL(),tf(this._store,e))),f(this,"getPromise",e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise())),f(this,"getNodes_UNSTABLE",e=>{if(this.checkRefCount_INTERNAL(),(null==e?void 0:e.isModified)===!0)return(null==e?void 0:e.isInitialized)===!1?[]:tu(this._store.getState().currentTree.dirtyAtoms);let t=this._store.getState().knownAtoms,n=this._store.getState().knownSelectors;return(null==e?void 0:e.isInitialized)==null?ts.values():!0===e.isInitialized?tu(te([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):ec(ts.values(),({key:e})=>!t.has(e)&&!n.has(e))}),f(this,"getInfo_UNSTABLE",({key:e})=>(this.checkRefCount_INTERNAL(),to(this._store,this._store.getState().currentTree,e))),f(this,"map",e=>{this.checkRefCount_INTERNAL();let t=new tR(this,tn);return e(t),t}),f(this,"asyncMap",async e=>{this.checkRefCount_INTERNAL();let t=new tR(this,tn);return t.retain(),await e(t),t.autoRelease_INTERNAL(),t}),this._store={storeID:ti(),getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{let n=e.graphsByVersion;if(n.has(t))return c(n.get(t));let r=ta();return n.set(t,r),r},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw s("Cannot subscribe to Snapshots")}},this._store.getState().knownAtoms))tr(this._store,t,"get"),tp(this._store,t,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&C("Attempt to retain() Snapshot that was already released."),this._refCount++;let e=!1;return()=>{e||(e=!0,this._release())}}autoRelease_INTERNAL(){tm||window.setTimeout(()=>this._release(),0)}_release(){if(this._refCount--,0===this._refCount){if(this._store.getState().nodeCleanupFunctions.forEach(e=>e()),this._store.getState().nodeCleanupFunctions.clear(),!L("recoil_memory_managament_2020"))return}else this._refCount}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){L("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function tv(e,t,n=!1){let r=e.getState(),o=n?ty():t.version;return{currentTree:n?{version:o,stateID:o,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()}:t,commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(r.knownAtoms),knownSelectors:new Set(r.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(o,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(M(r.nodeCleanupFunctions.entries(),([e])=>[e,()=>{}]))}}let[tb,tT]=tg((e,t)=>{let n=e.getState();return new tS(tv(e,"current"===t?n.currentTree:c(n.previousTree)))},(e,t)=>{var n;return String(t)+String(e.storeID)+String(e.getState().currentTree.version)+String(null==(n=e.getState().previousTree)?void 0:n.version)});class tR extends tS{constructor(e,t){super(tv(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0)),f(this,"_batch",void 0),f(this,"set",(e,t)=>{this.checkRefCount_INTERNAL();let n=this.getStore_INTERNAL();this._batch(()=>{tp(n,e.key,1),td(this.getStore_INTERNAL(),e,t)})}),f(this,"reset",e=>{this.checkRefCount_INTERNAL();let t=this.getStore_INTERNAL();this._batch(()=>{tp(t,e.key,1),td(this.getStore_INTERNAL(),e,tl)})}),f(this,"setUnvalidatedAtomValues_DEPRECATED",e=>{this.checkRefCount_INTERNAL();let t=this.getStore_INTERNAL();tn(()=>{for(let[n,r]of e.entries())tp(t,n,1),th(t,new tc(n),r)})}),this._batch=t}}var tw={Snapshot:tS,MutableSnapshot:tR,freshSnapshot:function(e){let t=new tS(t_());return null!=e?t.map(e):t},cloneSnapshot:function(e,t="current"){let n=tb(e,t);return n.isRetained()?n:(tT(),tb(e,t))}},tA=Object.freeze({__proto__:null,Snapshot:tw.Snapshot,MutableSnapshot:tw.MutableSnapshot,freshSnapshot:tw.freshSnapshot,cloneSnapshot:tw.cloneSnapshot}),tE=function(...e){let t=new Set;for(let n of e)for(let e of n)t.add(e);return t};let{useRef:tN}=i;var tk=function(e){let t=tN(e);return t.current===e&&"function"==typeof e&&(t.current=e()),t};let{getNextTreeStateVersion:tV,makeEmptyStoreState:tL}=ei,{cleanUpNode:tM,getDownstreamNodes:tC,initializeNode:tU,setNodeValue:tB,setUnvalidatedAtomValue_DEPRECATED:tD}=eT,{graph:tI}=J,{cloneGraph:tO}=J,{getNextStoreID:tx}=et,{createMutableSource:tP,reactMode:tz}=eE,{applyAtomValueWrites:tF}=eq,{releaseScheduledRetainablesNow:t$}=e3,{freshSnapshot:tW}=tA,{useCallback:tG,useContext:tj,useEffect:tH,useMemo:tq,useRef:tK,useState:tZ}=i;function tY(){throw s("This component must be used inside a <RecoilRoot> component.")}let tJ=Object.freeze({storeID:tx(),getState:tY,replaceState:tY,getGraph:tY,subscribeToTransactions:tY,addTransactionMetadata:tY}),tX=!1;function tQ(e){if(tX)throw s("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");let t=e.getState();if(null===t.nextTree){L("recoil_memory_managament_2020")&&L("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&t$(e);let n=t.currentTree.version,r=tV();t.nextTree={...t.currentTree,version:r,stateID:r,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(r,tO(c(t.graphsByVersion.get(n))))}}let t0=i.createContext({current:tJ}),t1=()=>tj(t0),t2=i.createContext(null);function t3(e,t,n){for(let r of tC(e,n,n.dirtyAtoms)){let e=t.nodeToComponentSubscriptions.get(r);if(e)for(let[t,[r,o]]of e)o(n)}}function t5(e){let t=e.getState(),n=t.currentTree,r=n.dirtyAtoms;if(r.size){for(let[n,o]of t.nodeTransactionSubscriptions)if(r.has(n))for(let[t,n]of o)n(e);for(let[n,r]of t.transactionSubscriptions)r(e);(!tz().early||t.suspendedComponentResolvers.size>0)&&(t3(e,t,n),t.suspendedComponentResolvers.forEach(e=>e()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(e=>e(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function t4({setNotifyBatcherOfChange:e}){let t=t1(),[,n]=tZ([]);return e(()=>n({})),tH(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),tH(()=>{$.enqueueExecution("Batcher",()=>{!function(e){let t=e.getState();t.commitDepth++;try{let{nextTree:n}=t;if(null===n)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,t5(e),null!=t.previousTree?t.graphsByVersion.delete(t.previousTree.version):C("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,L("recoil_memory_managament_2020")&&t$(e)}finally{t.commitDepth--}}(t.current)})}),null}let t7=0;function t6({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:r}){let o,a=e=>{let t=o.current.graphsByVersion;if(t.has(e))return c(t.get(e));let n=tI();return t.set(e,n),n},l=(e,t)=>{if(null==t){let{transactionSubscriptions:t}=h.current.getState(),n=t7++;return t.set(n,e),{release:()=>{t.delete(n)}}}{let{nodeTransactionSubscriptions:n}=h.current.getState();n.has(t)||n.set(t,new Map);let r=t7++;return c(n.get(t)).set(r,e),{release:()=>{let e=n.get(t);e&&(e.delete(r),0===e.size&&n.delete(t))}}}},s=e=>{for(let t of(tQ(h.current),Object.keys(e)))c(h.current.getState().nextTree).transactionMetadata[t]=e[t]},u=e=>{let t;tQ(h.current);let n=c(o.current.nextTree);try{tX=!0,t=e(n)}finally{tX=!1}t!==n&&(o.current.nextTree=t,tz().early&&t3(h.current,o.current,t),c(f.current)())},f=tK(null),d=tG(e=>{f.current=e},[f]),h=tk(()=>null!=n?n:{storeID:tx(),getState:()=>o.current,replaceState:u,getGraph:a,subscribeToTransactions:l,addTransactionMetadata:s});null!=n&&(h.current=n);let p=tq(()=>null==tP?void 0:tP(o,()=>o.current.currentTree.version),[o=tk(()=>null!=e?function(e,t){let n=tL();return t({set:(t,r)=>{let o=n.currentTree,a=tB(e,o,t.key,r),i=new Set(a.keys()),l=o.nonvalidatedAtoms.clone();for(let e of i)l.delete(e);n.currentTree={...o,dirtyAtoms:tE(o.dirtyAtoms,i),atomValues:tF(o.atomValues,a),nonvalidatedAtoms:l}},setUnvalidatedAtomValues:e=>{e.forEach((e,t)=>{n.currentTree=tD(n.currentTree,t,e)})}}),n}(h.current,e):null!=t?function(e){let t=tW().map(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(e=>e()),n.nodeCleanupFunctions.clear(),n}(t):tL())]);return tH(()=>{let e=h.current;for(let t of new Set(e.getState().knownAtoms))tU(e,t,"get");return()=>{for(let t of e.getState().knownAtoms)tM(e,t)}},[h]),i.createElement(t0.Provider,{value:h},i.createElement(t2.Provider,{value:p},i.createElement(t4,{setNotifyBatcherOfChange:d}),r))}var t9={RecoilRoot:function(e){let{override:t,...n}=e,r=t1();return!1===t&&r.current!==tJ?e.children:i.createElement(t6,n)},useStoreRef:t1,useRecoilMutableSource:function(){let e=tj(t2);return null==e&&k("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},useRecoilStoreID:function(){return t1().current.storeID},notifyComponents_FOR_TESTING:t3,sendEndOfBatchNotifications_FOR_TESTING:t5},t8=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,r=e.length;n<r;n++)if(e[n]!==t[n])return!1;return!0};let{useEffect:ne,useRef:nt}=i;var nn=function(e){let t=nt();return ne(()=>{t.current=e}),t.current};let{useStoreRef:nr}=t9,{SUSPENSE_TIMEOUT_MS:no}=e3,{updateRetainCount:na}=e3,{RetentionZone:ni}=es,{useEffect:nl,useRef:ns}=i,{isSSR:nu}=tt;var nc=function(e){if(L("recoil_memory_managament_2020"))return function(e){let t=(Array.isArray(e)?e:[e]).map(e=>e instanceof ni?e:e.key),n=nr();nl(()=>{if(!L("recoil_memory_managament_2020"))return;let e=n.current;if(r.current&&!nu)window.clearTimeout(r.current),r.current=null;else for(let n of t)na(e,n,1);return()=>{for(let n of t)na(e,n,-1)}},[n,...t]);let r=ns(),o=nn(t);if(!nu&&(void 0===o||!t8(o,t))){let e=n.current;for(let n of t)na(e,n,1);if(o)for(let t of o)na(e,t,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{for(let n of(r.current=null,t))na(e,n,-1)},no)}}(e)};let{useRef:nf}=i;var nd=function(){return nf(),"<component name not available>"};let{batchUpdates:nh}=e8,{DEFAULT_VALUE:np}=F,{reactMode:ny,useMutableSource:n_,useSyncExternalStore:nm}=eE,{useRecoilMutableSource:ng,useStoreRef:nS}=t9,{isRecoilValue:nv}=N,{AbstractRecoilValue:nb,getRecoilValueAsLoadable:nT,setRecoilValue:nR,setUnvalidatedRecoilValue:nw,subscribeToRecoilValue:nA}=eq,{useCallback:nE,useEffect:nN,useMemo:nk,useRef:nV,useState:nL}=i,{setByAddingToSet:nM}=eu;function nC(e,t,n){if("hasValue"===e.state)return e.contents;if("loading"===e.state)throw new Promise(e=>{n.current.getState().suspendedComponentResolvers.add(e)});if("hasError"===e.state)throw e.contents;throw s(`Invalid value of loadable atom "${t.key}"`)}function nU(e){let t=nS(),n=nd(),r=nE(()=>{var n;let r=t.current,o=r.getState();return{loadable:nT(r,e,ny().early&&null!=(n=o.nextTree)?n:o.currentTree),key:e.key}},[t,e]),o=nE(e=>{let t;return()=>{var n,r;let o=e();return null!=(n=t)&&n.loadable.is(o.loadable)&&(null==(r=t)?void 0:r.key)===o.key?t:(t=o,o)}},[]),a=nk(()=>o(r),[r,o]);return nm(nE(r=>nA(t.current,e,r,n).release,[t,e,n]),a,a).loadable}function nB(e){let t=nS(),n=nE(()=>{var n;let r=t.current,o=r.getState();return nT(r,e,ny().early&&null!=(n=o.nextTree)?n:o.currentTree)},[t,e]),r=nE(()=>n(),[n]),o=nd(),a=nE((r,a)=>nA(t.current,e,()=>{if(!L("recoil_suppress_rerender_in_callback"))return a();let e=n();u.current.is(e)||a(),u.current=e},o).release,[t,e,o,n]),i=ng();if(null==i)throw s("Recoil hooks must be used in components contained within a <RecoilRoot> component.");let l=n_(i,r,a),u=nV(l);return nN(()=>{u.current=l}),l}function nD(e){let t=nS(),n=nd(),r=nE(()=>{var n;let r=t.current,o=r.getState();return nT(r,e,ny().early&&null!=(n=o.nextTree)?n:o.currentTree)},[t,e]),o=nE(()=>({loadable:r(),key:e.key}),[r,e.key]),a=nE(e=>{let t=o();return e.loadable.is(t.loadable)&&e.key===t.key?e:t},[o]);nN(()=>{let r=nA(t.current,e,e=>{l(a)},n);return l(a),r.release},[n,e,t,a]);let[i,l]=nL(o);return i.key!==e.key?o().loadable:i.loadable}function nI(e){let t=nS(),[,n]=nL([]),r=nd(),o=nE(()=>{var n;let r=t.current,o=r.getState();return nT(r,e,ny().early&&null!=(n=o.nextTree)?n:o.currentTree)},[t,e]),a=o(),i=nV(a);return nN(()=>{i.current=a}),nN(()=>{let a=t.current,l=a.getState(),s=nA(a,e,e=>{var t;if(!L("recoil_suppress_rerender_in_callback"))return n([]);let r=o();null!=(t=i.current)&&t.is(r)||n(r),i.current=r},r);if(l.nextTree)a.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{i.current=null,n([])});else{var u;if(!L("recoil_suppress_rerender_in_callback"))return n([]);let e=o();null!=(u=i.current)&&u.is(e)||n(e),i.current=e}return s.release},[r,o,e,t]),a}function nO(e){return L("recoil_memory_managament_2020")&&nc(e),({TRANSITION_SUPPORT:nD,SYNC_EXTERNAL_STORE:nU,MUTABLE_SOURCE:nB,LEGACY:nI})[ny().mode](e)}function nx(e){let t=nS();return nC(nO(e),e,t)}function nP(e){let t=nS();return nE(n=>{nR(t.current,e,n)},[t,e])}function nz(e){return L("recoil_memory_managament_2020")&&nc(e),nD(e)}function nF(e){let t=nS();return nC(nz(e),e,t)}var n$=function(e,t){let n=new Map;for(let[r,o]of e)t(o,r)&&n.set(r,o);return n},nW=function(e,t){let n=new Set;for(let r of e)t(r)&&n.add(r);return n},nG=function(...e){let t=new Map;for(let n=0;n<e.length;n++){let r,o=e[n].keys();for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t};let{batchUpdates:nj}=e8,{DEFAULT_VALUE:nH,getNode:nq,nodes:nK}=F,{useStoreRef:nZ}=t9,{AbstractRecoilValue:nY,setRecoilValueLoadable:nJ}=eq,{SUSPENSE_TIMEOUT_MS:nX}=e3,{cloneSnapshot:nQ}=tA,{useCallback:n0,useEffect:n1,useRef:n2,useState:n3}=i,{isSSR:n5}=tt;function n4(e){let t=nZ();n1(()=>t.current.subscribeToTransactions(e).release,[e,t])}function n7(e){let t=Z(n$(e.atomValues.toMap(),(e,t)=>{let n=nq(t).persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state}),e=>e.contents);return nG(e.nonvalidatedAtoms.toMap(),t)}function n6(e,t){var n;let r=e.getState(),o=null!=(n=r.nextTree)?n:r.currentTree,a=t.getStore_INTERNAL().getState().currentTree;nj(()=>{let n=new Set;for(let e of[o.atomValues.keys(),a.atomValues.keys()])for(let t of e){var r,i;(null==(r=o.atomValues.get(t))?void 0:r.contents)!==(null==(i=a.atomValues.get(t))?void 0:i.contents)&&nq(t).shouldRestoreFromSnapshots&&n.add(t)}n.forEach(t=>{nJ(e,new nY(t),a.atomValues.has(t)?c(a.atomValues.get(t)):nH)}),e.replaceState(e=>({...e,stateID:t.getID()}))})}var n9={useRecoilSnapshot:function(){let e=nZ(),[t,n]=n3(()=>nQ(e.current)),r=nn(t),o=n2(),a=n2();if(n4(n0(e=>n(nQ(e)),[])),n1(()=>{let e=t.retain();if(o.current&&!n5){var n;window.clearTimeout(o.current),o.current=null,null==(n=a.current)||n.call(a),a.current=null}return e},[t]),r!==t&&!n5){if(o.current){var i;window.clearTimeout(o.current),o.current=null,null==(i=a.current)||i.call(a),a.current=null}a.current=t.retain(),o.current=window.setTimeout(()=>{var e;o.current=null,null==(e=a.current)||e.call(a),a.current=null},nX)}return t},gotoSnapshot:n6,useGotoRecoilSnapshot:function(){let e=nZ();return n0(t=>n6(e.current,t),[e])},useRecoilTransactionObserver:function(e){n4(n0(t=>{e({snapshot:nQ(t,"current"),previousSnapshot:nQ(t,"previous")})},[e]))},useTransactionObservation_DEPRECATED:function(e){n4(n0(t=>{let n=t.getState().previousTree,r=t.getState().currentTree;n||(C("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);let o=n7(r),a=n7(n),i=Z(nK,e=>{var t,n,r,o;return{persistence_UNSTABLE:{type:null!=(t=null==(n=e.persistence_UNSTABLE)?void 0:n.type)?t:"none",backButton:null!=(r=null==(o=e.persistence_UNSTABLE)?void 0:o.backButton)&&r}}}),l=nW(r.dirtyAtoms,e=>o.has(e)||a.has(e));e({atomValues:o,previousAtomValues:a,atomInfo:i,modifiedAtoms:l,transactionMetadata:{...r.transactionMetadata}})},[e]))},useTransactionSubscription_DEPRECATED:n4};let{peekNodeInfo:n8}=eT,{useStoreRef:re}=t9,{reactMode:rt}=eE,{RecoilRoot:rn,useStoreRef:rr}=t9,{useMemo:ro}=i,{loadableWithValue:ra}=T,{initializeNode:ri}=eT,{DEFAULT_VALUE:rl,getNode:rs}=F,{copyTreeState:ru,getRecoilValueAsLoadable:rc,invalidateDownstreams:rf,writeLoadableToTreeState:rd}=eq;function rh(e){return"atom"===rs(e.key).nodeType}class rp{constructor(e,t){f(this,"_store",void 0),f(this,"_treeState",void 0),f(this,"_changes",void 0),f(this,"get",e=>{if(this._changes.has(e.key))return this._changes.get(e.key);if(!rh(e))throw s("Reading selectors within atomicUpdate is not supported");let t=rc(this._store,e,this._treeState);if("hasValue"===t.state)return t.contents;if("hasError"===t.state)throw t.contents;throw s(`Expected Recoil atom ${e.key} to have a value, but it is in a loading state.`)}),f(this,"set",(e,t)=>{if(!rh(e))throw s("Setting selectors within atomicUpdate is not supported");if("function"==typeof t){let n=this.get(e);this._changes.set(e.key,t(n))}else ri(this._store,e.key,"set"),this._changes.set(e.key,t)}),f(this,"reset",e=>{this.set(e,rl)}),this._store=e,this._treeState=t,this._changes=new Map}newTreeState_INTERNAL(){if(0===this._changes.size)return this._treeState;let e=ru(this._treeState);for(let[t,n]of this._changes)rd(e,t,ra(n));return rf(this._store,e),e}}var ry=Object.freeze({__proto__:null,atomicUpdater:function(e){return t=>{e.replaceState(n=>{let r=new rp(e,n);return t(r),r.newTreeState_INTERNAL()})}}}),r_=function(e,t){if(!e)throw Error(t)};let{atomicUpdater:rm}=ry,{batchUpdates:rg}=e8,{DEFAULT_VALUE:rS}=F,{useStoreRef:rv}=t9,{refreshRecoilValue:rb,setRecoilValue:rT}=eq,{Snapshot:rR,cloneSnapshot:rw}=tA,{gotoSnapshot:rA}=n9,{useCallback:rE}=i;class rN{}let rk=new rN;function rV(e,t,n,r){let o=rk;return rg(()=>{let a="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!=typeof t)throw s(a);let i=t(ef({...null!=r?r:{},set:(t,n)=>rT(e,t,n),reset:t=>rT(e,t,rS),refresh:t=>rb(e,t),gotoSnapshot:t=>rA(e,t),transact_UNSTABLE:t=>rm(e)(t)},{snapshot:()=>rw(e)}));if("function"!=typeof i)throw s(a);o=i(...n)}),o instanceof rN&&r_(!1),o}var rL={recoilCallback:rV,useRecoilCallback:function(e,t){let n=rv();return rE((...t)=>rV(n.current,e,t),null!=t?[...t,n]:void 0)}};let{useStoreRef:rM}=t9,{refreshRecoilValue:rC}=eq,{useCallback:rU}=i,{atomicUpdater:rB}=ry,{useStoreRef:rD}=t9,{useMemo:rI}=i;class rO{constructor(e){var t,n,r;f(this,"_numLeafs",void 0),f(this,"_root",void 0),f(this,"_onHit",void 0),f(this,"_onSet",void 0),f(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=null!=(t=null==e?void 0:e.onHit)?t:()=>{},this._onSet=null!=(n=null==e?void 0:e.onSet)?n:()=>{},this._mapNodeValue=null!=(r=null==e?void 0:e.mapNodeValue)?r:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var n;return null==(n=this.getLeafNode(e,t))?void 0:n.value}getLeafNode(e,t){return rx(this.root(),t=>this._mapNodeValue(e(t)),{onNodeVisit:e=>{null==t||t.onNodeVisit(e),"leaf"===e.type&&this._onHit(e)}})}set(e,t,n){let r,o=null,a=()=>{o=rP(this.root(),e.map(([e,t])=>[e,this._mapNodeValue(t)]),null,t,null,{onNodeVisit:e=>{null==n||n.onNodeVisit(e),"leaf"===e.type&&(r=e)}},()=>{this.clear(),a()})};a(),this.root()||(this._root=o),this._numLeafs++,this._onSet(c(r))}delete(e){if(!this.root())return!1;let t=c(this.root());return!!rz(t,e,e.parent)&&(e!==t&&("branch"!==t.type||t.branches.size)?this._numLeafs-=r$(e):(this._root=null,this._numLeafs=0),!0)}clear(){this._numLeafs=0,this._root=null}}let rx=(e,t,n)=>{var r;if(null==e)return;if(null==n||null==(r=n.onNodeVisit)||r.call(n,e),"leaf"===e.type)return e;let o=t(e.nodeKey);return rx(e.branches.get(o),t,n)},rP=(e,t,n,r,o,a,i)=>{var l;let s;if(null==e)if(0===t.length)s={type:"leaf",value:r,parent:n,branchKey:o};else{let[e,...l]=t,[u,c]=e;(s={type:"branch",nodeKey:u,parent:n,branches:new Map,branchKey:o}).branches.set(c,rP(null,l,s,r,c,a,i))}else if(s=e,t.length){let[n,...o]=t,[l,u]=n;if("branch"!==e.type||e.nodeKey!==l)return C("Existing cache must have a branch midway through the route with matching node key. Resetting cache."),i(),s;e.branches.set(u,rP(e.branches.get(u),o,e,r,u,a,i))}return null==a||null==(l=a.onNodeVisit)||l.call(a,s),s},rz=(e,t,n)=>n?(n.branches.delete(t.branchKey),rF(e,n,n.parent)):e===t,rF=(e,t,n)=>n?(0===t.branches.size&&n.branches.delete(t.branchKey),rF(e,n,n.parent)):e===t,r$=e=>"leaf"===e.type?1:Array.from(e.branches.values()).reduce((e,t)=>e+r$(t),0);var rW=Object.freeze({__proto__:null,TreeCache:{TreeCache:rO}.TreeCache});class rG{constructor(e){var t;f(this,"_maxSize",void 0),f(this,"_size",void 0),f(this,"_head",void 0),f(this,"_tail",void 0),f(this,"_map",void 0),f(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!=(t=e.mapKey)?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){let t=this._keyMapper(e),n=this._map.get(t);if(n)return this.set(e,n.value),n.value}set(e,t){let n=this._keyMapper(e);this._map.get(n)&&this.delete(e);let r=this.head(),o={key:e,right:r,left:null,value:t};r?r.left=o:this._tail=o,this._map.set(n,o),this._head=o,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){let e=this.tail();e&&this.delete(e.key)}delete(e){let t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;let n=c(this._map.get(t)),r=n.right,o=n.left;r&&(r.left=n.left),o&&(o.right=n.right),n===this.head()&&(this._head=r),n===this.tail()&&(this._tail=o),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}var rj=Object.freeze({__proto__:null,LRUCache:{LRUCache:rG}.LRUCache});let{LRUCache:rH}=rj,{TreeCache:rq}=rW;var rK=function(e,t=e=>e){let n=new rH({maxSize:e}),r=new rq({mapNodeValue:t,onHit:e=>{n.set(e,!0)},onSet:t=>{let o=n.tail();n.set(t,!0),o&&r.size()>e&&r.delete(o.key)}});return r},rZ=function(e,t={allowFunctions:!1}){return function e(t,n,r){if("string"==typeof t&&!t.includes('"')&&!t.includes("\\"))return`"${t}"`;switch(typeof t){case"undefined":return"";case"boolean":return t?"true":"false";case"number":case"symbol":return String(t);case"string":return JSON.stringify(t);case"function":if((null==n?void 0:n.allowFunctions)!==!0)throw s("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${t.name})__`}if(null===t)return"null";if("object"!=typeof t){var o;return null!=(o=JSON.stringify(t))?o:""}if(u(t))return"__PROMISE__";if(Array.isArray(t))return`[${t.map((t,r)=>e(t,n,r.toString()))}]`;if("function"==typeof t.toJSON)return e(t.toJSON(r),n,r);if(t instanceof Map){let o={};for(let[r,a]of t)o["string"==typeof r?r:e(r,n)]=a;return e(o,n,r)}return t instanceof Set?e(Array.from(t).sort((t,r)=>e(t,n).localeCompare(e(r,n))),n,r):void 0!==Symbol&&null!=t[Symbol.iterator]&&"function"==typeof t[Symbol.iterator]?e(Array.from(t),n,r):`{${Object.keys(t).filter(e=>void 0!==t[e]).sort().map(r=>`${e(r,n)}:${e(t[r],n,r)}`).join(",")}}`}(e,t)};let{TreeCache:rY}=rW,rJ={equality:"reference",eviction:"keep-all",maxSize:1/0},{isReactNative:rX,isSSR:rQ}=tt,{loadableWithError:r0,loadableWithPromise:r1,loadableWithValue:r2}=T,{getNodeLoadable:r3,peekNodeLoadable:r5,setNodeValue:r4}=eT,{saveDependencyMapToStore:r7}=J,{DEFAULT_VALUE:r6,RecoilValueNotReady:r9,getConfigDeletionHandler:r8,getNode:oe,registerNode:ot}=F,{isRecoilValue:on}=N,{markRecoilValueModified:or}=eq,{retainedByOptionWithDefault:oo}=e3,{recoilCallback:oa}=rL,{startPerfBlock:oi}={startPerfBlock:function(e){return()=>null}};class ol{}let os=new ol,ou=[],oc=new Map,of=(()=>{let e=0;return()=>e++})();var od=function(e){let t=null,{key:n,get:r,cachePolicy_UNSTABLE:o}=e,a=null!=e.set?e.set:void 0,i=new Set,l=function({equality:e=rJ.equality,eviction:t=rJ.eviction,maxSize:n=rJ.maxSize}=rJ){var r=t,o=n,a=function(e){switch(e){case"reference":return e=>e;case"value":return e=>rZ(e)}throw s(`Unrecognized equality policy ${e}`)}(e);switch(r){case"keep-all":return new rY({mapNodeValue:a});case"lru":return rK(c(o),a);case"most-recent":return rK(1,a)}throw s(`Unrecognized eviction policy ${r}`)}(null!=o?o:{equality:"reference",eviction:"keep-all"}),f=oo(e.retainedBy_UNSTABLE),d=new Map,h=0;function p(){return!L("recoil_memory_managament_2020")||h>0}function y(e){return e.getState().knownSelectors.add(n),h++,()=>{h--}}function _(){return void 0!==r8(n)&&!p()}function m(e,t,n,r,o){C(t,r,o),T(e,t,new Set(o.keys()),n),g(e,n)}function g(e,n){M(e,n)&&V(e);let r=oc.get(n);if(void 0!==r){for(let e of r)or(e,c(t));oc.delete(n)}}function S(e,t){let n=oc.get(t);null==n&&oc.set(t,n=new Set),n.add(e)}function v(e,t,n){let r=e.getState().knownSelectors.has(n);if(r&&t.atomValues.has(n))return c(t.atomValues.get(n));let o=r3(e,t,n);return"loading"!==o.state&&r&&t.atomValues.set(n,o),o}function b(e,t,n,r,o,a){return t.then(r=>{if(!p())throw V(e),os;null!=a.loadingDepKey&&a.loadingDepPromise===t?n.atomValues.set(a.loadingDepKey,r2(r)):e.getState().knownSelectors.forEach(e=>{n.atomValues.delete(e)});let i=w(e,n);if(i&&"loading"!==i.state){if((M(e,o)||null==N(e))&&g(e,o),"hasValue"===i.state)return i.contents;throw i.contents}if(!M(e,o)){let e=A(n);if((null==e?void 0:e.latestLoadable.state)==="loading")return e.latestLoadable.contents}let[l,s]=R(e,n,o);if(k(e,o,s),"loading"!==l.state&&m(e,n,o,l,s),"hasError"===l.state)throw l.contents;return l.contents}).catch(t=>{if(t instanceof ol)throw os;if(!p())throw V(e),os;throw m(e,n,o,r0(t),r),t})}function T(e,t,r,o){var a,l,s,u,c,f,d;(M(e,o)||t.version===(null==(a=e.getState())||null==(l=a.currentTree)?void 0:l.version)||t.version===(null==(s=e.getState())||null==(u=s.nextTree)?void 0:u.version))&&(r7(new Map([[n,r]]),e,null!=(c=null==(f=e.getState())||null==(d=f.nextTree)?void 0:d.version)?c:e.getState().currentTree.version),r.forEach(e=>i.add(e)))}function R(e,o,a){let i,l=oi(n),c=!0,f=()=>{l(),c=!1},d=!1,h={loadingDepKey:null,loadingDepPromise:null},y=new Map,_=new Set;function g(t){let{key:n}=t;_.add(n),T(e,o,_,a);let r=v(e,o,n);switch(y.set(n,r),r.state){case"hasValue":return r.contents;case"hasError":throw r.contents;case"loading":throw h.loadingDepKey=n,h.loadingDepPromise=r.contents,r.contents}throw s("Invalid Loadable state")}T(e,o,_,a);try{if(i=r({get:g,getCallback:n=>(...r)=>{if(c)throw s("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return null==t&&r_(!1),oa(e,n,r,{node:t})}}),i=on(i)?g(i):i,u(i)){var S;i=(S=i,S.then(t=>{if(!p())throw V(e),os;return m(e,o,a,r2(t),y),t}).catch(t=>{if(!p())throw V(e),os;if(k(e,a,y),u(t))return b(e,t,o,y,a,h);throw m(e,o,a,r0(t),y),t})).finally(f)}else f()}catch(t){u(i=t)?i=b(e,i,o,y,a,h).finally(f):(d=!0,f())}return[d?r0(i):u(i)?r1(i):r2(i),y]}function w(e,t){let r,o=new Set,a=N(e);try{r=l.get(n=>("string"!=typeof n&&r_(!1),v(e,t,n).contents),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==n&&o.add(e.nodeKey)}})}catch(e){throw s(`Problem with cache lookup for selector "${n}": ${e.message}`)}return r&&T(e,t,o,null==a?void 0:a.latestExecutionId),r}function A(e){var t;let[,n]=null!=(t=Array.from(d.entries()).find(([t,n])=>null!=n.latestLoadable&&null!=n.latestExecutionId&&!function(e,t){var n,r;let o=N(e),a=null!=(n=null==o?void 0:o.depValuesDiscoveredSoFarDuringAsyncWork)?n:new Map,i=Array((null!=(r=E.get(t.version))?r:new Map).entries()),l=E.has(t.version)&&i.length===a.size&&i.every(([e,t])=>a.get(e)===t);return null!=a&&t.version!==(null==o?void 0:o.stateVersion)&&!l&&(E.set(t.version,new Map(a)),Array.from(a).some(([n,r])=>v(e,t,n).contents!==r.contents))}(t,e)))?t:[];return n}let E=new Map;function N(e){return d.get(e)}function k(e,t,n){if(M(e,t)){let t=N(e);null!=t&&(t.depValuesDiscoveredSoFarDuringAsyncWork=n)}}function V(e){d.delete(e)}function M(e,t){var n;return t===(null==(n=N(e))?void 0:n.latestExecutionId)}function C(e,t,r){e.atomValues.set(n,t);try{l.set(Array.from(r.entries()).map(([e,t])=>[e,t.contents]),t)}catch(e){throw s(`Problem with setting cache for selector "${n}": ${e.message}`)}}function U(e,t){return l.get(n=>{var r;return"string"!=typeof n&&r_(!1),null==(r=r5(e,t,n))?void 0:r.contents})}function B(e,t){if(ou.includes(n))return r0(s(`Recoil selector has circular dependencies: ${ou.slice(ou.indexOf(n)).join(" → ")}`));ou.push(n);try{return function(e,t){var n,r,o,a,i,l;let s=w(e,t);if(null!=s)return V(e),s;let u=A(t);if(null!=u){return(null==(n=u.latestLoadable)?void 0:n.state)==="loading"&&S(e,c(u.latestExecutionId)),c(u.latestLoadable)}let f=of(),[h,p]=R(e,t,f);return"loading"===h.state?(r=e,o=f,a=h,i=p,l=t,d.set(r,{depValuesDiscoveredSoFarDuringAsyncWork:i,latestExecutionId:o,latestLoadable:a,stateVersion:l.version}),S(e,f)):(V(e),C(t,h,p)),h}(e,t)}finally{ou.pop()}}function D(e){e.atomValues.delete(n)}function I(e,n){for(let o of(null==t&&r_(!1),i)){var r;let t=oe(o);null==(r=t.clearCache)||r.call(t,e,n)}i.clear(),D(n),l.clear(),or(e,t)}return t=null!=a?ot({key:n,nodeType:"selector",peek:U,get:B,set:(e,t,n)=>{let r=!1,o=new Map;function i({key:n}){if(r)throw s("Recoil: Async selector sets are not currently supported.");let o=v(e,t,n);if("hasValue"===o.state)return o.contents;if("loading"===o.state)throw new r9(n);throw o.contents}function l(n,a){if(r)throw s("Recoil: Async selector sets are not currently supported.");let l="function"==typeof a?a(i(n)):a;r4(e,t,n.key,l).forEach((e,t)=>o.set(t,e))}let c=a({set:l,get:i,reset:function(e){l(e,r6)}},n);if(void 0!==c)throw u(c)?s("Recoil: Async selector sets are not currently supported."):s("Recoil: selector set should be a void function.");return r=!0,o},init:y,invalidate:D,clearCache:I,shouldDeleteConfigOnRelease:_,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:f}):ot({key:n,nodeType:"selector",peek:U,get:B,init:y,invalidate:D,clearCache:I,shouldDeleteConfigOnRelease:_,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:f})};let{loadableWithError:oh,loadableWithPromise:op,loadableWithValue:oy}=T,{peekNodeInfo:o_}=eT,{DEFAULT_VALUE:om,DefaultValue:og,getConfigDeletionHandler:oS,registerNode:ov,setConfigDeletionHandler:ob}=F,{isRecoilValue:oT}=N,{getRecoilValueAsLoadable:oR,markRecoilValueModified:ow,setRecoilValue:oA,setRecoilValueLoadable:oE}=eq,{retainedByOptionWithDefault:oN}=e3;function ok(e){let{default:t,...n}=e;return oT(t)?function(e){let t=ok({...e,default:om,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof og?t:c(e.persistence_UNSTABLE).validator(t,om)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=od({key:`${e.key}__withFallback`,get:({get:n})=>{let r=n(t);return r instanceof og?e.default:r},set:({set:e},n)=>e(t,n),dangerouslyAllowMutability:e.dangerouslyAllowMutability});return ob(n.key,oS(e.key)),n}({...n,default:t}):function(e){var t;let n,{key:r,persistence_UNSTABLE:o}=e,a=oN(e.retainedBy_UNSTABLE),i=0,l=u(e.default)?op(e.default.then(e=>(l=oy(e),e)).catch(e=>{throw l=oh(e),e})):oy(e.default);t=e.default;let f=new Map;function d(e,t){var o,a;return null!=(o=null!=(a=t.atomValues.get(r))?a:n)?o:l}let h=ov({key:r,nodeType:"atom",peek:d,get:function(e,t){if(t.atomValues.has(r))return c(t.atomValues.get(r));if(!t.nonvalidatedAtoms.has(r))return l;{if(null!=n)return n;if(null==o)return k(`Tried to restore a persisted value for atom ${r} but it has no persistence settings.`),l;let e=t.nonvalidatedAtoms.get(r),a=o.validator(e,om);return n=a instanceof og?l:oy(a)}},set:function(e,t,o){if(t.atomValues.has(r)){let e=c(t.atomValues.get(r));if("hasValue"===e.state&&o===e.contents)return new Map}else if(!t.nonvalidatedAtoms.has(r)&&o instanceof og)return new Map;return n=void 0,new Map().set(r,oy(o))},init:function(t,n,o){var a,c,p;i++,t.getState().knownAtoms.add(r),"loading"===l.state&&l.contents.finally(()=>{var e;(null!=(e=t.getState().nextTree)?e:t.getState().currentTree).atomValues.has(r)||ow(t,h)});let y=null!=(a=e.effects)?a:e.effects_UNSTABLE;if(null!=y){let e=!0,a=om,i=!1,S=null;function _(o){if(e&&o.key===r){let e=a;return e instanceof og?d(t,n):u(e)?op(e.then(e=>e instanceof og?l.toPromise():e)):oy(e)}return oR(t,o)}function m(e){return _(e).toPromise()}function g(n){var o;let i=o_(t,null!=(o=t.getState().nextTree)?o:t.getState().currentTree,n.key);return!e||n.key!==r||a instanceof og?i:{...i,isSet:!0,loadable:_(n)}}let v=n=>r=>{if(e){let e=_(h),t="hasValue"===e.state?e.contents:om;u(a="function"==typeof r?r(t):r)&&(a=a.then(e=>(S={effect:n,value:e},e)))}else{if(u(r))throw s("Setting atoms to async values is not implemented.");"function"!=typeof r&&(S={effect:n,value:r}),oA(t,h,"function"==typeof r?e=>{let t=r(e);return S={effect:n,value:t},t}:r)}},b=e=>()=>v(e)(om),T=e=>n=>{var o;let{release:a}=t.subscribeToTransactions(t=>{var o,a,i,s,u;let{currentTree:c,previousTree:f}=t.getState();f||(C("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),f=c);let d=null!=(o=c.atomValues.get(r))?o:l;if("hasValue"===d.state){let t=d.contents,o=null!=(a=f.atomValues.get(r))?a:l,h="hasValue"===o.state?o.contents:om;(null==(i=S)?void 0:i.effect)!==e||(null==(s=S)?void 0:s.value)!==t?n(t,h,!c.atomValues.has(r)):(null==(u=S)?void 0:u.effect)===e&&(S=null)}},r);f.set(t,[...null!=(o=f.get(t))?o:[],a])};for(let e of y)try{let n=e({node:h,storeID:t.storeID,trigger:o,setSelf:v(e),resetSelf:b(e),onSet:T(e),getPromise:m,getLoadable:_,getInfo_UNSTABLE:g});null!=n&&f.set(t,[...null!=(c=f.get(t))?c:[],n])}catch(e){a=e,i=!0}if(e=!1,!(a instanceof og)){let e=a,o=i?oh(a):u(e)?op(function(e,t){let n=t.then(t=>{var o,a;return(null==(a=(null!=(o=e.getState().nextTree)?o:e.getState().currentTree).atomValues.get(r))?void 0:a.contents)===n&&oA(e,h,t),t}).catch(t=>{var o,a;throw(null==(a=(null!=(o=e.getState().nextTree)?o:e.getState().currentTree).atomValues.get(r))?void 0:a.contents)===n&&oE(e,h,oh(t)),t});return n}(t,e)):oy(e);n.atomValues.set(r,o),null==(p=t.getState().nextTree)||p.atomValues.set(r,o)}}return()=>{var e;i--,null==(e=f.get(t))||e.forEach(e=>e()),f.delete(t)}},invalidate:function(){n=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==oS(r)&&i<=0},dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:a});return h}({...n,default:t})}class oV{constructor(e){var t;f(this,"_map",void 0),f(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!=(t=null==e?void 0:e.mapKey)?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}}var oL=Object.freeze({__proto__:null,MapCache:{MapCache:oV}.MapCache});let{LRUCache:oM}=rj,{MapCache:oC}=oL,oU={equality:"reference",eviction:"none",maxSize:1/0};var oB=function({equality:e=oU.equality,eviction:t=oU.eviction,maxSize:n=oU.maxSize}=oU){var r=t,o=n,a=function(e){switch(e){case"reference":return e=>e;case"value":return e=>rZ(e)}throw s(`Unrecognized equality policy ${e}`)}(e);switch(r){case"keep-all":return new oC({mapKey:a});case"lru":return new oM({mapKey:a,maxSize:c(o)});case"most-recent":return new oM({mapKey:a,maxSize:1})}throw s(`Unrecognized eviction policy ${r}`)};let{setConfigDeletionHandler:oD}=F,{setConfigDeletionHandler:oI}=F,oO=0;var ox=function(e){var t,n;let r=oB({equality:null!=(t=null==(n=e.cachePolicyForParams_UNSTABLE)?void 0:n.equality)?t:"value",eviction:"keep-all"});return t=>{var n;let o,a=r.get(t);if(null!=a)return a;let i=`${e.key}__selectorFamily/${null!=(n=rZ(t,{allowFunctions:!0}))?n:"void"}/${oO++}`,l=n=>e.get(t)(n),s=e.cachePolicy_UNSTABLE,u="function"==typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;if(null!=e.set){let n=e.set;o=od({key:i,get:l,set:(e,r)=>n(t)(e,r),cachePolicy_UNSTABLE:s,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u})}else o=od({key:i,get:l,cachePolicy_UNSTABLE:s,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u});return r.set(t,o),oI(o.key,()=>{r.delete(t)}),o}};let oP=ox({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}}),oz=ox({key:"__error",get:e=>()=>{throw s(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}}),{loadableWithError:oF,loadableWithPromise:o$,loadableWithValue:oW}=T;function oG(e,t){let n=Array(t.length).fill(void 0),r=Array(t.length).fill(void 0);for(let[o,a]of t.entries())try{n[o]=e(a)}catch(e){r[o]=e}return[n,r]}function oj(e){return null!=e&&!u(e)}function oH(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function oq(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((e,n,r)=>({...e,[n]:t[r]}),{})}function oK(e,t,n){return oq(e,n.map((e,n)=>null==e?oW(t[n]):u(e)?o$(e):oF(e)))}let oZ=ox({key:"__waitForNone",get:e=>({get:t})=>{let[n,r]=oG(t,oH(e));return oK(e,n,r)},dangerouslyAllowMutability:!0}),oY=ox({key:"__waitForAny",get:e=>({get:t})=>{let[n,r]=oG(t,oH(e));return r.some(e=>!u(e))?oK(e,n,r):new Promise(t=>{for(let[o,a]of r.entries())u(a)&&a.then(a=>{n[o]=a,r[o]=void 0,t(oK(e,n,r))}).catch(a=>{r[o]=a,t(oK(e,n,r))})})},dangerouslyAllowMutability:!0}),oJ=ox({key:"__waitForAll",get:e=>({get:t})=>{let[n,r]=oG(t,oH(e));if(r.every(e=>null==e))return oq(e,n);let o=r.find(oj);if(null!=o)throw o;return Promise.all(r).then(t=>oq(e,t.map((e,t)=>void 0===e?n[t]:e)))},dangerouslyAllowMutability:!0}),oX=ox({key:"__waitForAllSettled",get:e=>({get:t})=>{let[n,r]=oG(t,oH(e));return r.every(e=>!u(e))?oK(e,n,r):Promise.all(r.map((e,t)=>u(e)?e.then(e=>{n[t]=e,r[t]=void 0}).catch(e=>{n[t]=void 0,r[t]=e}):null)).then(()=>oK(e,n,r))},dangerouslyAllowMutability:!0}),oQ=ox({key:"__noWait",get:e=>({get:t})=>{try{return oW(t(e))}catch(e){return u(e)?o$(e):oF(e)}},dangerouslyAllowMutability:!0}),{RecoilLoadable:o0}=T,{DefaultValue:o1}=F,{RecoilRoot:o2,useRecoilStoreID:o3}=t9,{isRecoilValue:o5}=N,{retentionZone:o4}=es,{freshSnapshot:o7}=tA,{useRecoilState:o6,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:o9,useRecoilStateLoadable:o8,useRecoilValue:ae,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:at,useRecoilValueLoadable:an,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:ar,useResetRecoilState:ao,useSetRecoilState:aa}={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useRecoilInterface:function(){let e=nd(),t=nS(),[,n]=nL([]),r=nV(new Set);r.current=new Set;let o=nV(new Set),a=nV(new Map),i=nE(e=>{let t=a.current.get(e);t&&(t.release(),a.current.delete(e))},[a]),l=nE((e,t)=>{a.current.has(t)&&n([])},[]);return nN(()=>{let n=t.current;K(r.current,o.current).forEach(t=>{if(a.current.has(t))return void k(`Double subscription to RecoilValue "${t}"`);let r=nA(n,new nb(t),e=>l(e,t),e);a.current.set(t,r),n.getState().nextTree?n.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{l(n.getState(),t)}):l(n.getState(),t)}),K(o.current,r.current).forEach(e=>{i(e)}),o.current=r.current}),nN(()=>{let n=a.current;return K(r.current,new Set(n.keys())).forEach(r=>{let o=nA(t.current,new nb(r),e=>l(e,r),e);n.set(r,o)}),()=>n.forEach((e,t)=>i(t))},[e,t,i,l]),nk(()=>{function e(e){return n=>{nR(t.current,e,n)}}function n(e){var n;r.current.has(e.key)||(r.current=nM(r.current,e.key));let o=t.current.getState();return nT(t.current,e,ny().early&&null!=(n=o.nextTree)?n:o.currentTree)}function o(e){return nC(n(e),e,t)}return{getRecoilValue:o,getRecoilValueLoadable:n,getRecoilState:function(t){return[o(t),e(t)]},getRecoilStateLoadable:function(t){return[n(t),e(t)]},getSetRecoilState:e,getResetRecoilState:function(e){return()=>nR(t.current,e,np)}}},[r,t])},useRecoilState:function(e){return[nx(e),nP(e)]},useRecoilStateLoadable:function(e){return[nO(e),nP(e)]},useRecoilValue:nx,useRecoilValueLoadable:nO,useResetRecoilState:function(e){let t=nS();return nE(()=>{nR(t.current,e,np)},[t,e])},useSetRecoilState:nP,useSetUnvalidatedAtomValues:function(){let e=nS();return(t,n={})=>{nh(()=>{e.current.addTransactionMetadata(n),t.forEach((t,n)=>nw(e.current,new nb(n),t))})}},useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:nz,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:nF,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:function(e){return[nF(e),nP(e)]}},{useGotoRecoilSnapshot:ai,useRecoilSnapshot:al,useRecoilTransactionObserver:as}=n9,{useRecoilCallback:au}=rL,{noWait:ac,waitForAll:af,waitForAllSettled:ad,waitForAny:ah,waitForNone:ap}={waitForNone:oZ,waitForAny:oY,waitForAll:oJ,waitForAllSettled:oX,noWait:oQ};var ay={DefaultValue:o1,isRecoilValue:o5,RecoilLoadable:o0,RecoilRoot:o2,useRecoilStoreID:o3,useRecoilBridgeAcrossReactRoots_UNSTABLE:function(){"MUTABLE_SOURCE"===rt().mode&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");let e=rr().current;return ro(()=>function({children:t}){return i.createElement(rn,{store_INTERNAL:e},t)},[e])},atom:ok,selector:od,atomFamily:function(e){var t,n;let r=oB({equality:null!=(t=null==(n=e.cachePolicyForParams_UNSTABLE)?void 0:n.equality)?t:"value",eviction:"keep-all"});return t=>{var n,o;let a=r.get(t);if(null!=a)return a;let{cachePolicyForParams_UNSTABLE:i,...l}=e,s=ok({...l,key:`${e.key}__${null!=(n=rZ(t))?n:"void"}`,default:"function"==typeof e.default?e.default(t):e.default,retainedBy_UNSTABLE:"function"==typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE,effects:"function"==typeof e.effects?e.effects(t):"function"==typeof e.effects_UNSTABLE?e.effects_UNSTABLE(t):null!=(o=e.effects)?o:e.effects_UNSTABLE});return r.set(t,s),oD(s.key,()=>{r.delete(t)}),s}},selectorFamily:ox,constSelector:function(e){return oP(e)},errorSelector:function(e){return oz(e)},readOnlySelector:function(e){return e},noWait:ac,waitForNone:ap,waitForAny:ah,waitForAll:af,waitForAllSettled:ad,useRecoilValue:ae,useRecoilValueLoadable:an,useRecoilState:o6,useRecoilStateLoadable:o8,useSetRecoilState:aa,useResetRecoilState:ao,useGetRecoilValueInfo_UNSTABLE:function(){let e=re();return({key:t})=>n8(e.current,e.current.getState().currentTree,t)},useRecoilRefresher_UNSTABLE:function(e){let t=rM();return rU(()=>{rC(t.current,e)},[e,t])},useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:ar,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:at,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:o9,useRecoilCallback:au,useRecoilTransaction_UNSTABLE:function(e,t){let n=rD();return rI(()=>(...t)=>{rB(n.current)(n=>{e(n)(...t)})},null!=t?[...t,n]:void 0)},useGotoRecoilSnapshot:ai,useRecoilSnapshot:al,useRecoilTransactionObserver_UNSTABLE:as,snapshot_UNSTABLE:o7,useRetain:nc,retentionZone:o4};ay.DefaultValue,ay.isRecoilValue,ay.RecoilLoadable;var a_=ay.RecoilRoot;ay.useRecoilStoreID,ay.useRecoilBridgeAcrossReactRoots_UNSTABLE;var am=ay.atom;ay.selector,ay.atomFamily,ay.selectorFamily,ay.constSelector,ay.errorSelector,ay.readOnlySelector,ay.noWait,ay.waitForNone,ay.waitForAny,ay.waitForAll,ay.waitForAllSettled;var ag=ay.useRecoilValue;ay.useRecoilValueLoadable;var aS=ay.useRecoilState;ay.useRecoilStateLoadable;var av=ay.useSetRecoilState;ay.useResetRecoilState,ay.useGetRecoilValueInfo_UNSTABLE,ay.useRecoilRefresher_UNSTABLE,ay.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,ay.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,ay.useRecoilState_TRANSITION_SUPPORT_UNSTABLE,ay.useRecoilCallback,ay.useRecoilTransaction_UNSTABLE,ay.useGotoRecoilSnapshot,ay.useRecoilSnapshot,ay.useRecoilTransactionObserver_UNSTABLE,ay.snapshot_UNSTABLE,ay.useRetain,ay.retentionZone}}]);